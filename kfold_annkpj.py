# -*- coding: utf-8 -*-
"""KFold_annKPJ.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mKP54QpyO8eFPpaQusXUM0eZMnTxr_iK

# DATA PREPROCESSING
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import tensorflow as tf
# %matplotlib inline

tf.__version__

dataset = pd.read_csv('/content/drive/MyDrive/Master/MANB2153/csv_result-heart-statlog (1).csv')
X = dataset.iloc[:,1:-1].values
y = dataset.iloc[:,-1].values

"""## **DATA PREPROCESSING**"""

from sklearn.preprocessing import LabelEncoder #for only 2 class (Yes or No)
le = LabelEncoder()
y = le.fit_transform(y)

"""## **KFOLD CROSS VALIDATION FOR ANN**"""

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X = sc.fit_transform(X)

#keras.wrappers is use to implement the k-cross validation
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import cross_val_score
from keras.models import Sequential
from keras.layers import Dense
from sklearn.model_selection import StratifiedKFold
	
def create_baseline():
    # create model
    model = tf.keras.models.Sequential()
    model.add(tf.keras.layers.Dense(60, activation='relu'))
    model.add(tf.keras.layers.Dense(60, activation='relu'))
    model.add(tf.keras.layers.Dense(1, activation='sigmoid'))
    # Compile model
    model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
    return model

# evaluate model with standardized dataset
estimator = KerasClassifier(build_fn=create_baseline, epochs=100, batch_size=5,     verbose=0)
kfold1 = StratifiedKFold(n_splits=2, shuffle=True, random_state=0)
kfold2 = StratifiedKFold(n_splits=5, shuffle=True, random_state=0)
kfold3 = StratifiedKFold(n_splits=10, shuffle=True, random_state=0)
results1 = cross_val_score(estimator, X, y, cv=kfold1)
results2 = cross_val_score(estimator, X, y, cv=kfold2)
results3 = cross_val_score(estimator, X, y, cv=kfold3)
print("Baseline: %.2f%% (%.2f%%)" % (results1.mean()*100, results1.std()*100))
print("Baseline: %.2f%% (%.2f%%)" % (results2.mean()*100, results2.std()*100))
print("Baseline: %.2f%% (%.2f%%)" % (results3.mean()*100, results3.std()*100))

#to obtain prediction value of y
from sklearn.model_selection import cross_val_predict
y_pred1 = cross_val_predict(estimator, X, y, cv=kfold1)
y_pred2 = cross_val_predict(estimator, X, y, cv=kfold2)
y_pred3 = cross_val_predict(estimator, X, y, cv=kfold3)

#CONFUSION MATRIX AND ACCURACY
from sklearn.metrics import confusion_matrix, accuracy_score
cm1 = confusion_matrix(y, y_pred1)
print(cm1)
acc1 = accuracy_score(y, y_pred1)
print(acc1)

cm2 = confusion_matrix(y, y_pred2)
print(cm2)
acc2 = accuracy_score(y, y_pred2)
print(acc2)

cm3 = confusion_matrix(y, y_pred3)
print(cm3)
acc3 = accuracy_score(y, y_pred3)
print(acc3)

"""## **ANN TRAIN TEST VALIDATION**"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state=1)

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

model4 = tf.keras.models.Sequential()
model4.add(tf.keras.layers.Dense(units=60, activation='relu')) #rectifier activation function
model4.add(tf.keras.layers.Dense(units=60, activation='relu')) #rectifier activation function
model4.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))
model4.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])
model4.fit(X_train, y_train, batch_size = 5, epochs =100)

#CONFUSION MATRIX AND ACCURACY
from sklearn.metrics import confusion_matrix, accuracy_score
y_pred4 = model4.predict(X_test)
y_pred4 = (y_pred4>0.5)
cm4 = confusion_matrix(y_test, y_pred4)
print(cm4)
acc4 = accuracy_score(y_test, y_pred4)
print(acc4)

model5 = tf.keras.models.Sequential()
model5.add(tf.keras.layers.Dense(units=60, activation='relu')) #rectifier activation function
model5.add(tf.keras.layers.Dense(units=60, activation='relu')) #rectifier activation function
model5.add(tf.keras.layers.Dense(units=60, activation='relu')) #rectifier activation function
model5.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))
model5.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])
model5.fit(X_train, y_train, batch_size = 5, epochs =100)
#CONFUSION MATRIX AND ACCURACY
from sklearn.metrics import confusion_matrix, accuracy_score
y_pred5 = model1.predict(X_test)
y_pred5 = (y_pred5>0.5)
cm5 = confusion_matrix(y_test, y_pred5)
print(cm5)
acc5 = accuracy_score(y_test, y_pred5)
print(acc5)

model6 = tf.keras.models.Sequential()
model6.add(tf.keras.layers.Dense(units=60, activation='relu')) #rectifier activation function
model6.add(tf.keras.layers.Dense(units=60, activation='relu')) #rectifier activation function
model6.add(tf.keras.layers.Dense(units=60, activation='relu')) #rectifier activation function
model6.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))
model6.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])
model6.fit(X_train, y_train, batch_size = 5, epochs =100)
#CONFUSION MATRIX AND ACCURACY
from sklearn.metrics import confusion_matrix, accuracy_score
y_pred6 = model1.predict(X_test)
y_pred6 = (y_pred5>0.5)
cm6 = confusion_matrix(y_test, y_pred6)
print(cm6)
acc6 = accuracy_score(y_test, y_pred6)
print(acc6)

import sklearn.metrics as metrics
# calculate the fpr and tpr for all thresholds of the classification
probs1 = model4.predict_proba(X_test)
probs2 = model5.predict_proba(X_test)
probs3 = model6.predict_proba(X_test)

probs1

import sklearn.metrics as metrics
# calculate the fpr and tpr for all thresholds of the classification
probs1 = model4.predict_proba(X_test)
probs2 = model5.predict_proba(X_test)
probs3 = model6.predict_proba(X_test)
preds1 = probs1[:,:]
preds2 = probs2[:,:]
preds3 = probs3[:,:]
fpr1, tpr1, threshold1 = metrics.roc_curve(y_test, preds1)
fpr2, tpr2, threshold2 = metrics.roc_curve(y_test, preds2)
fpr3, tpr3, threshold3 = metrics.roc_curve(y_test, preds3)
roc_auc1 = metrics.auc(fpr1, tpr1)
roc_auc2 = metrics.auc(fpr2, tpr2)
roc_auc3 = metrics.auc(fpr3, tpr3)

# method I: plt
import matplotlib.pyplot as plt
plt.title('Receiver Operating Characteristic')
plt.plot(fpr1, tpr1, 'r', label = 'AUC = %0.2f' % roc_auc1)
plt.plot(fpr2, tpr2, 'g', label = 'AUC = %0.2f' % roc_auc2)
plt.plot(fpr3, tpr3, 'b', label = 'AUC = %0.2f' % roc_auc3)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1],'r--')
plt.xlim([0, 1])
plt.ylim([0, 1])
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()

#Test the model
#Define input

a=271  #ID
b=30   #age
c=1    #sex
d=4    #chest
e=160  #resting_blood_pressure
f=286  #serum_cholestoral
g=5    #fasting_blood_sugar
h=2    #resting_electrocardiographic_results
i=108  #maximum_heart_rate_achieved
j=1    #exercise_induced_angina
k=1.5  #oldpeak
l=2    #slope
m=3    #number_of_major_vessels
n=3    #thal

new_input = [[a,b,c,d,e,f,g,h,i,j,k,l,m,n]]
X_new = sc.transform(new_input)
y_new = model.predict(X_new)
print(y_new)
if y_new==1:
    print('Potential Heart Disease Patient')
else:
    print('Healthy Patient')